%% Compute point on non-uniform rational B-spline surface
% Input:  u, knotspanIndex, degree, knotVector
% Output: point on non-uniform rational B-spline surface
%
% Xu Yi, 2019

%%
function surfacePt = NurbsSrfPt(u, degreeU, knotVectorU, v, degreeV, knotVectorV, cvPtX, cvPtY, cvPtZ, weightVector)
% u
knotspanIndexU = FindSpan(u, degreeU, knotVectorU);
[basisFunValueU, dersBasisFunValueU] = BasisFuns(u, degreeU, knotVectorU);
% v
knotspanIndexV = FindSpan(v, degreeV, knotVectorV);
[basisFunValueV, dersBasisFunValueV] = BasisFuns(v, degreeV, knotVectorV);
%
WcvPtX = cvPtX.* weightVector;
WcvPtY = cvPtY.* weightVector;
WcvPtZ = cvPtZ.* weightVector;
W = basisFunValueU(end,:)...
    * weightVector( (knotspanIndexU-degreeU):knotspanIndexU, (knotspanIndexV-degreeV):knotspanIndexV )...
    * basisFunValueV(end,:)';
surfacePtX = basisFunValueU(end,:)...
    * WcvPtX( (knotspanIndexU-degreeU):knotspanIndexU, (knotspanIndexV-degreeV):knotspanIndexV )...
    * basisFunValueV(end,:)'...
    / W;
surfacePtY = basisFunValueU(end,:)...
    * WcvPtY( (knotspanIndexU-degreeU):knotspanIndexU, (knotspanIndexV-degreeV):knotspanIndexV )...
    * basisFunValueV(end,:)'...
    / W;
surfacePtZ = basisFunValueU(end,:)...
    * WcvPtZ( (knotspanIndexU-degreeU):knotspanIndexU, (knotspanIndexV-degreeV):knotspanIndexV )...
    * basisFunValueV(end,:)'...
    / W;
surfacePt = [surfacePtX, surfacePtY, surfacePtZ];
end
