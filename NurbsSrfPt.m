%% Compute point on non-uniform rational B-spline surface
% Input:  u,v, degree(U,V), knotVector(U,V), cvPt(X,Y,Z), weightVector
% Output: point on non-uniform rational B-spline surface
%
% Xu Yi, 2019

%%
function surfacePt = NurbsSrfPt(u, degreeU, knotVectorU, v, degreeV, knotVectorV, cvPtX, cvPtY, cvPtZ, weightVector)
% u
knotspanIndexU = FindSpan(u, knotVectorU);
[basisFunValueU, dersBasisFunValueU] = BasisFuns(u, degreeU, knotVectorU);
% v
knotspanIndexV = FindSpan(v, knotVectorV);
[basisFunValueV, dersBasisFunValueV] = BasisFuns(v, degreeV, knotVectorV);
%
WcvPtX = cvPtX.* weightVector;
WcvPtY = cvPtY.* weightVector;
WcvPtZ = cvPtZ.* weightVector;
W = basisFunValueU(end,:)...
    * weightVector( (knotspanIndexU-degreeU):knotspanIndexU, (knotspanIndexV-degreeV):knotspanIndexV )...
    * basisFunValueV(end,:)';
PtX = basisFunValueU(end,:)...
    * WcvPtX( (knotspanIndexU-degreeU):knotspanIndexU, (knotspanIndexV-degreeV):knotspanIndexV )...
    * basisFunValueV(end,:)'...
    / W;
PtY = basisFunValueU(end,:)...
    * WcvPtY( (knotspanIndexU-degreeU):knotspanIndexU, (knotspanIndexV-degreeV):knotspanIndexV )...
    * basisFunValueV(end,:)'...
    / W;
PtZ = basisFunValueU(end,:)...
    * WcvPtZ( (knotspanIndexU-degreeU):knotspanIndexU, (knotspanIndexV-degreeV):knotspanIndexV )...
    * basisFunValueV(end,:)'...
    / W;
surfacePt = [PtX, PtY, PtZ];
end
