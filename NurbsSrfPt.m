%% Compute point on non-uniform rational B-spline surface
% Input:  u,v, degree(U,V), knotVector(U,V), cvPt(X,Y,Z), weightVector
% Output: point on non-uniform rational B-spline surface
% column:u / row:v
% Xu Yi, 2019

%%
function surfacePt = NurbsSrfPt(u, degreeU, knotVectorU, v, degreeV, knotVectorV, cvPtX, cvPtY, cvPtZ, weightVector)
% u
knotspanIndexU = FindSpan(u, knotVectorU);
[basisFunValueU, dersBasisFunValueU] = BasisFuns(u, degreeU, knotVectorU);
% v
knotspanIndexV = FindSpan(v, knotVectorV);
[basisFunValueV, dersBasisFunValueV] = BasisFuns(v, degreeV, knotVectorV);
%
WcvPtX = cvPtX.* weightVector;
WcvPtY = cvPtY.* weightVector;
WcvPtZ = cvPtZ.* weightVector;

if knotspanIndexU == length(knotVectorU) - degreeU && knotspanIndexV == length(knotVectorV) - degreeV % special case
    PtX = cvPtX(end,end);
    PtY = cvPtY(end,end);
    PtZ = cvPtZ(end,end);
elseif knotspanIndexU == length(knotVectorU) - degreeU % special case / like curve @ V
    W = basisFunValueV(end,:)...
        * ( weightVector( end , (knotspanIndexV-degreeV):knotspanIndexV )' );
    PtX = basisFunValueV(end,:)...
        * ( WcvPtX( end , (knotspanIndexV-degreeV):knotspanIndexV )' )...
        / W;
    PtY = basisFunValueV(end,:)...
        * ( WcvPtY( end , (knotspanIndexV-degreeV):knotspanIndexV )' )...
        / W;
    PtZ = basisFunValueV(end,:)...
        * ( WcvPtZ( end , (knotspanIndexV-degreeV):knotspanIndexV )' )...
        / W;
elseif knotspanIndexV == length(knotVectorV) - degreeV % special case / like curve @ U
    W = basisFunValueU(end,:)...
        * ( weightVector( (knotspanIndexU-degreeU):knotspanIndexU , end ) );
    PtX = basisFunValueU(end,:)...
        * ( WcvPtX( (knotspanIndexU-degreeU):knotspanIndexU , end ) )...
        / W;
    PtY = basisFunValueU(end,:)...
        * ( WcvPtY( (knotspanIndexU-degreeU):knotspanIndexU , end ) )...
        / W;
    PtZ = basisFunValueU(end,:)...
        * ( WcvPtZ( (knotspanIndexU-degreeU):knotspanIndexU , end ) )...
        / W;
else
    W = basisFunValueU(end,:)...
        * weightVector( (knotspanIndexU-degreeU):knotspanIndexU, (knotspanIndexV-degreeV):knotspanIndexV )...
        * basisFunValueV(end,:)';
    PtX = basisFunValueU(end,:)...
        * WcvPtX( (knotspanIndexU-degreeU):knotspanIndexU, (knotspanIndexV-degreeV):knotspanIndexV )...
        * basisFunValueV(end,:)'...
        / W;
    PtY = basisFunValueU(end,:)...
        * WcvPtY( (knotspanIndexU-degreeU):knotspanIndexU, (knotspanIndexV-degreeV):knotspanIndexV )...
        * basisFunValueV(end,:)'...
        / W;
    PtZ = basisFunValueU(end,:)...
        * WcvPtZ( (knotspanIndexU-degreeU):knotspanIndexU, (knotspanIndexV-degreeV):knotspanIndexV )...
        * basisFunValueV(end,:)'...
        / W;
end
surfacePt = [PtX, PtY, PtZ];
end
